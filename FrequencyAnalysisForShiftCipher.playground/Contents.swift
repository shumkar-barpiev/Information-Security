import UIKit
import Darwin
//Frequency Analysis for Affine Cipher







let alphabetEnglish = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"]

var cipherText = "KYZJHLVJKZFETRDVWIFDVCFEDLJBEVRIKYVMVIPVEUFWRCFEXUZEEVINVJYRIVURKRYZXYVEUJVRWFFUIVJKRLIREKZEJZCZTFEMRCCVPZUXFKKVEKFKYVIVJKRLIREKWZIJKREUJVKKCVUUFNENZKYRXZEREUKFEZTBEFNZEXDLJBNFLCURJVMVISVCRKVRWKVIRSFLKWZWKVVEDZELKVJDLJBJYFNVULGNVRIZEXCVRKYVIJYFVJUVJZXEVIAVREJREURGCRZUUIVJJJYZIKDLJBJKREUJJZOWFFKFEVSLKRJBREPFEVNYFBEFNJYZDREUKYVPCCTFEWZIDKYRKYVJVVDJDLTYSZXXVIKYREKYRKYVJRSJLIUCPSIFRUJYFLCUVIVUJKLIUPREUKYZTBPFLUWZXLIVYVNFLCULJVKYZJWIRDVKFYZJRUMREKRXVREUGVIWFIDRERCGYRDRCVJKILKNYVEVEKVIZEXRIFFDZEJKVRUYVKVEUJKFSVRCDFJKJYVVGZJYZKJYVRUKZCKVUJCZXYKCPUFNENYZCVNRCBZEXRHLZTBYREUJYRBVYVCCFRWKVIIVRTYZEXKYVKRSCVREUKYVESLKKZEJVRKWIFDKYVIVDLJBEVVUJRWVNDZELKVJSVWFIVYVNRIDJLGREUCFFBJRKVRJVDLJBRJBVUDVKFUZEEVIWFIREVXFKZRKZFEFWJFIKJVZXYKVVEDFEKYJVRICZVIZUZEWFIDVUYZDFWDPGCREJKFNIZKVRSFFBRSFLKYZDREUYVUZEWFIDVUDVFWYZJGCREJEFKKFTFFGVIRKVYZJIVAVTKZFEJKLEXSLKKYILJKDVZEKFUFXXVUIVGFIKVIDFUVZWZYRUKFUFKYZJSFFBNZKYFLKYZDJFSVZKGCVEKPFWGVFGCVYRUCVWKDLJBJTFDGREZVJKVJCRDFKFIJREUJGRTVOREUNFLCUKRCBREUZRCIVRUPBEVNRCFKFWYZJWIZVEUJKYVZEKVIMZVNJWFCCFNVUFEVRWKVIREFKYVIDFEKYRWKVIDFEKYREUKNFYLEUIVUFIJFGVFGCVZEKFKYVGIFTVJJZYVRIUWIFDDLJBFETVRXRZEYVTRCCVUDVRKYFDVREUUVTCRIVUKYRKKYZEXJTFLCUXFFEVFWKNFNRPJYVTFLCUDRBVDPCZWVMVIPUZWWZTLCKFIYVTFLCUYVCGNZKYKYVGIFAVTKRWKVIRCCYVUSVNZCCZEXKFTFFGVIRKVZWYVTFLCUIVRUKYVSFFBSVWFIVZKNVEKKFGLSCZTRKZFEREUTFLCURUUWFFKEFKVJKYIFLXYFLKZKYVNFLCUEFKDVUUCVNZKYDPKVOKSLKYVNREKVUKYVTYRETVKFJVKKYVIVTFIUJKIRZXYKZEJGFKJKYRKYVUVVDVUWRTKLRCCPZERTTLIRKVZLEUVIJKFFUNYVIVKYZJNRJTFDZEXWIFDDLJBNREKVURDVRJLIVFWTFEKIFCFMVIYZJCZWVJJKFIPYVJRCJFNZIVUCZBVRJTZVEKZJKREUJLWWVIJDVEKRCREXLZJYRKKYVJZXYKFWRWRTKLRCVIIFIRDZJKRBVFERGIZEKVUGRXVNFLCUXERNRKYZJJFLCWFIVMVINYZCVZTFLCULEUVIJKREUYZJGVIJGVTKZMVZTFLCUEFKCVKYZDIVRUKYVSFFBWFIGIFWVJJZFERCGVIJFERCREUGIRTKZTRCIVRJFEJDLJBYRJYZJMVIJZFEFWKYVKILKYREUZKJEFKRCNRPJKYVMVIJZFEFWKYVKILKYKYRKKYVIVJKFWKYVNFICUJYRIVJYVJGIFEVKFMVISFJVREJNVIJKFVMVEKYVJZDGCVJKFWHLVJKZFEJRJNVCCREUKYVKYFLXYKFWKYZIKPGRXVWFFKEFKVJJVVDVURCCKFFIVRCJKZCCNVRXIVVUKFYRMVUZEEVITYRKRCCKYZJFLKREUJVVNYVIVZKCVWKLJ"

//key = "R"

var cipherTextArr = Array(cipherText)
let orderFrequencyLetters = ["E", "T", "A", "O", "N", "I", "S", "R", "H", "L", "D", "C", "U", "P", "F", "M", "W", "Y", "B", "G", "V", "K", "Q", "X", "J", "Z"]


for key in 16...20{
    var decrypTextArr =  [Character]()

    for i in Range(0...cipherText.count-1){
        let c = alphabetEnglish.firstIndex(of: String(cipherTextArr[i]))!
        let k = alphabetEnglish.firstIndex(of: String(alphabetEnglish[key]))!
        var D = (c-k)%26
        
        if D < 0{ //if D is negative
            D += 26
        }
        
        decrypTextArr.append(contentsOf: alphabetEnglish[D])
    }
    
//    print(String(decrypTextArr))
    
    var dictOfFrequencyLetters = [String:Int]()
    var orderingMaxFrequencedLetters = [String]()

    for i in alphabetEnglish{
        let count = decrypTextArr.filter({$0 == Character(i)}).count
        dictOfFrequencyLetters[String(i)] = count
    }
    
    for _ in 0...5{
        let maxVal = dictOfFrequencyLetters.max { $0.value < $1.value }
        
    //  print(maxVal!.key, maxVal!.value)
        orderingMaxFrequencedLetters.append(String(maxVal!.key))
        dictOfFrequencyLetters[maxVal!.key] = nil
    }
    print(orderingMaxFrequencedLetters)
    
    if orderFrequencyLetters[0] == orderingMaxFrequencedLetters[0] && orderFrequencyLetters[1] == orderingMaxFrequencedLetters[1]{
        
        print("key is :", alphabetEnglish[key])
        break
    }
    
}


