
alphabetEnglish = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"]
orderFrequencyLetters = ["E", "T", "A", "O", "N", "I", "S", "R", "H", "L", "D", "C", "U", "P", "F", "M", "W", "Y", "B", "G", "V", "K", "Q", "X", "J", "Z"]

encryptedText = "EBKCBOGCECQXNUOOQLQWPFQXXOUUYYCBEBGFPLAOYXQPLFQXRXKXYYTGPMJKCYFKEUJSRBGXOMGKQIQNCYUDLOTKYNKXDCNSNIPFLFNOJCFQZNVOYNQDSYTODNCECUPDQCTCEUPNDYVDWYFNZQPGTNJKRCPKYXVYYCEUYIYSYAOEDEYYFFFKDYXOCVGVLNGKQNGBLVQEEZKPEYGXXCPEEYUWFMMCSIYOOORGPUTSYANOLNJOCMJYPMFODCIXPLLOLHUKYXCZWUKNOLGCDMJSCNOEDEUDLHFCDCZPZIVYYYDEEUUULHAYYYYRZEPYHMJSXUPNEBGIWFEYYZKBXNJKEBGCPYOCXOERMCIQPLVRLHVRLNJODUDCFLFVJVTYLXURZONNPLGNDNWBOSCXONJSNEAYFXHSROTOSYYYFFFEDYVRTMHBLGGDZBKCLXXKYNCQPUPNAYTPZLOKYUNZSUOKWYUDCOVGSYPOYNGBTHIKCIQWTHUDPUFRPNGXOMVYMYCVXIUDDBGOACURTNURPUFDTFVOOMNSRBVVJXQGYQJSWYYKWEKXRUSETWMRLHFCSUMOSYNVZUHDPLTOLWJSYAVRPNCLWYCXONJOYVWDECPCPUVPCIODSYTOXOUUYYGNDUHOHGKXFNGCMYHYCYJOHUTWDORKYXNYZEUKEYCCPGWCVUUUPXOOEIFSYHGBQITKYYIYECCDTIPYQMQBEMGSRBVOPHOYYNJCPUTVTYTSOCPPZLOOOBKWZZOIAFCXDNQGCCVOLVQYVUDYFNJSXUPNSYFSYZQBXYFWPIHRTMRVLHUXZNVYNIQZPLCDPBKCCYLONNKYYMVEYADEENJBFMVWPCPDZXQQRYFBPJQBEYTWZXGSQCJKONQNZNJSDVQYVQKDSIWDSCOCZVGSEJNOYNAYQJGYAFGRLXNOQNOEDEUMZGRKYCGCEYUVLGQDZLUKYXUZLWGHLHFGZONNEUNULHFSLFTOLXAUYYYKWIVYQBKCQLKOYXUDSCUAFYUDTIPMLGGPCIOOWIPWFMMXPUTDSYXOCSGXOIHKWIPQOCPXPLYODBCBPXCDLBKQSYPNDYCPZIFBPMVKFLCXECPCTFKMZHXKWFGITXIYENGXEIVRPLGCEUWBLHVPTLUDLHFCPNVVPXFYHHYSEBCQTHCXONQXTWMXZQKXRGWCVQQEWXCCPPGBMYNKEYCPEYTKMIWDQCHDPYPWTHWDPMOEDEURZQGNFJYOLLKXRFGKEBGBDBQODXGCTAPOCDGKYMCXOURVLCFNCYUCDBKBEGWCVMVKYXUCTRHYZNQXPVWDLMMKYSQXPQJYVHQGDBKWLHFDSYAVWWQXQCTWEBCDSYUOPGUWFWJLTAIOCNJKYNJKEBGCLVUECXNIMLQKOMJYFFFOCYFCEOTNJUPNEBKMVSQEOZKQFLGRPQQEWXWCPNJSDZTKXYVYSCUKOPCXEUIOLHFZPLHYCGCXLFRRLGCVPMVBFNYRPHGXEYTSYACBZIOSYMVOLXJOEYPNDNQLPUNWZMVCSYGZTMJSEMJOLXVSWNGNDFKQSNNIOIYXHBKVPQCVVCPQLKWSNEJKYXURLEGRPFNYLZVOCLGKNBKXRNJOEUDVPUPNEBGXMOVDTHUOLNHBZGVRPLGWFMMXPYFCLZGGXCPEEYULPZQBPBGGLLOCFJCXOFQYVMCDPUUOXOUULMMOOGGDZXKXYYTPZLCXPAQDTUVSZHQPDITDDYKQSNGOYGQXEBUOLLNSPLKNTHHYCGGNSCOYQGAZWUPCEIYBTNGKMIQULVQEEBKWLHFRPXKXQITWPXOOZZJSDJNKYMPYENQMZIROCUVOSCUBPDGMECQXDNWXRVWDEBTEDNOOTHVYOIIQPXTOAITDPLOYOYKPTBCNEIFYEBKCMIQUHCVRZOVRTGUYMYKDAFGXESQPAYQZWYJKOFGPEGWCVMEYXJCXTYUDPMNKXIVYCMCXOMRKNYZKYXYYFFFDLFMKYXKKWLGKOSMXPQCVZNQPSCUPCCGXOMVRTMSEPMVSZHEKXYHBZGGVZHOEDEPOLLVRPPGBJYPNZZCVZHINTHPOCQGCSUTOOUVKSCIRPHFCPUHYZXTODNCECUPDTHUSWCEYYPCVWYASOAQDEYPDZNJOCYUDLOTKYNHSCMVKYXUOENNOOXQGYQKDSUISYUPNEIPSNEPYHCPQXOUUHIWVOUUOGYTLPFCDPUHDPLCLZOVPTZVOPHOSYOVODGWCVMJYHYFEAQGKCCPQWYCDSYTCSIGCOYUSRHGBUYCXDUPNLJNKTXFBPMUCSCTDXOUUDNCXOMUSIZQYEIPOMOVKDECXJIPOHBQUYIYCSCOKYXVRPSNVNIPPTLODSUVRPMGOXMOENBDSRAGBEBCXEBCDSYUKMMWBOFALCICNDBQEWXGBPXUDFLFILHFDSCEUJIWNQCIECYJOHIWVOOUOEBKCQLCWPNQRTMCNGUPDLAGKYXROCZQBXUPKWJJKXUNODNTEEQJOYYPDPLKXRUTYZGKXDNGKOBGDPHFCEIDOLFOYDNURPYRSDBKDDBGKONKVEYFCWCIREFANZQPGSCNOHUNUTHIKBOKMVBCXOMJKVYJOWFQKQNGBCYCMSCPQEBGDLVNOLHFDSYPLFNVSYMGKEZTYXNJOCYOEDEPOPXUKQYYWTHWDPMDOQITOSYYKCGUEAUPNWIQUDUVOLMGWFMMKDEGNXYVYOCPXPLHYCUPORIVSLNKYYIHCZLVCPCIREYGXXIPDSMGKCFKOCCFSYZQBXYFRTGQPXSRVLHUDZQTSEYCLZIMKMIWDSCOKYXJOOCPPZLOOOGGYQBKCAFCXDHQDEIEYZJGBLNGRTMTOUYEDTIPCEOPQMOVDSLWCEGGSYNQNZAIOOLGZZLVOCGQNPCHSSUFDZXQDSCULZIMGTNJYFNJSXMQLPCVZWYPDJIHZPIRVPBCNWYHDXOUUDWQWAUPSPMVODFCWZNQBDUPNDJCMPRCXOQQEWXVKWECXOCCVCYCNJEPOHUNYEIHRTMHBTYPNDNJSDKWODNKYYWCWPZTYXYNYYGWCVHGKCNJOGYTIPHFYQUNYYAFSYHGBHYURLLGNLNCRTAJOYXUOLZQYOLGCEUWBLHVSYMKVTWQXGUNVPSKNRIVDPHVYEBGBPMVKFLCXEZKBDNCXOMGDEFGNOIYXHCVRLAKXLHFDZHKMVHQGTHIWFMMGZONNLMGFPLDOWUVOLZVOCUDYFNHSQNGOYGKXFNGCXOUUDBQGPXWZHYCBTHIVPUVRPLURZYUNPMKQYYTTPUPCLHFKAFCSOXTODMURTLVWFMMCEUPNDMKHQIQDZHGLFNCCVUPIZHGGSIMXZQURTGCXONJOJFNMZHHSCGVRLNJODYGWDGWMSVKQRYTDSUPDSUVRPMCLDOTNWSDBZUFCSIWVOYTOOMVECXAKYXVRTWMIZOFPTAWBPBGGZONNFMGDSCUPCUOOEIJSDUFFLHVKRYCXOJGBQITWLHCVABCWLFGCELWDHBGXPHVOCCPQLLQYXCPCEYCNSYVOYXUDZVGKWGQCEMJOPJKCSCVCSYCNECNDPXUVTAJDWSFYHHYRTFGGLFMSYACAFCEUSUPNDBCUPBGVWICPEYTBPUERTHIDSYVKMFGKYXVRPHDEENKXDYCDQLQWEBGBPGWCVHGOOMCPPQOSYOVODVGPZLGRPQCBXMWZLHFVZIMCLNGKDYOEDECCVYFWPNQNTHPOCZQBLHGQZNKKECQXZZUYCNUOTAJDPYPWZHVRDYCBWCGBTXKXQITWPXJSXIHWJJNKYMVYHLKDPUDYZECLZOVRTGCXOBGNTHHYCGGNXYQPSCUZWUPCYIVDZWQYAYTKEYJSDLGTPWVSZHUDFHILFNVRCOUDXYKXEIFYRAGNCYRYCNGBXIFOTZKRLXVYOIVRTMDYZEYSEBQEEBKWDIDOTNRVPHVIZZROZJNOSUFVPZVWFMMCNIOZLHKOD"


def findKeyLength(encryptedTextArr):
    subGroupLetters = []
    lengthOfVigeniereCipher = 0
    keyRange = 15

    for key in range(1, keyRange):
        tempEncTextArr = encryptedTextArr
        k = len(encryptedTextArr) % key
        completeSymbCount = key - k

        for i in range(0, completeSymbCount):
            tempEncTextArr += "."

        for i in range(0, len(tempEncTextArr), key):
            subGroupLetters.append(tempEncTextArr[i])


        countLetters = []
        countOfLetter = len(subGroupLetters)
        I = 0.0

        for i in alphabetEnglish:
            count = subGroupLetters.count(i)
            countLetters.append(count)

        for i in countLetters:
            I += float((i * (i - 1))) / float((countOfLetter * (countOfLetter - 1)))


        if I >= 0.060 and I <= 0.070:
            lengthOfVigeniereCipher = key
            break

        subGroupLetters.clear()


    return lengthOfVigeniereCipher

key = findKeyLength(encryptedText)
encryptedTextArr = [*encryptedText]

groupLetters = []

tempEncTextArr = encryptedTextArr
k = len(encryptedTextArr) % key
completeSymbCount = key - k

for _ in range(0, completeSymbCount):
    tempEncTextArr += "."

for i in range(0, key):
    subGroupLetters = []
    for j in range(-key + i, len(tempEncTextArr) - key, key):
        subGroupLetters.append(tempEncTextArr[j + key])
    groupLetters.append(subGroupLetters)

for i in range(0, len(groupLetters)):
    if "." in groupLetters[i]:
        groupLetters[i].remove(".")

keyWord = ""

for i in groupLetters:
    cipherTextArr = i
    dictionaryKeyWord = {}

    for key in range(0, 26):
        decrypTextArr = []

        for i in range(0, len(cipherTextArr)):
            c = alphabetEnglish.index(cipherTextArr[i])
            k = alphabetEnglish.index(alphabetEnglish[key])
            D = (c - k) % 26

            if D < 0:
                D += 26 #if D is negative

            decrypTextArr.append(alphabetEnglish[D])

        dictOfFrequencyLetters = {}
        orderingMaxFrequencedLetters = []

        for i in alphabetEnglish:
            count = decrypTextArr.count(i)
            dictOfFrequencyLetters[i] = count

        for i in range(0, len(dictOfFrequencyLetters)):
            v = list(dictOfFrequencyLetters.values())
            k = list(dictOfFrequencyLetters.keys())

            orderingMaxFrequencedLetters.append(k[v.index(max(v))])
            del dictOfFrequencyLetters[k[v.index(max(v))]]

        counter = 0


        for i in range(0, 26):
            if orderFrequencyLetters[i] == orderingMaxFrequencedLetters[i]:
                counter += 1

        dictionaryKeyWord[alphabetEnglish[key]] = counter

    v = list(dictionaryKeyWord.values())
    k = list(dictionaryKeyWord.keys())

    keyWord += k[v.index(max(v))]


print("Key word is: ", keyWord)

lengthKey = len(keyWord)
lengthPlaintext = len(encryptedText)
num = int(lengthPlaintext/lengthKey) #type is integer butun san
num1 = lengthPlaintext%lengthKey #type is integer kaldyk san

arrLetters = [*keyWord]
vigenereKey = ""


for _ in range(0, num):
    vigenereKey += keyWord

if num1 >= 1:
    for i in range(0, num1):
        vigenereKey += arrLetters[i]


charVigenereKey = [*vigenereKey]
decrypTextArr1 = []

for i in range(0, len(encryptedTextArr)):
    if "." in encryptedTextArr:
        encryptedTextArr.remove(".")

for i in range(0, len(encryptedTextArr)):
    c = alphabetEnglish.index(encryptedTextArr[i])
    k = alphabetEnglish.index(charVigenereKey[i])
    D = (c - k) % 26

    if D < 0: # if D is negative
        D += 26

    decrypTextArr1.append(alphabetEnglish[D])

decrypText1 = "".join(map(str, decrypTextArr1))

print("\n\nDecryption Result :")
print(decrypText1)


